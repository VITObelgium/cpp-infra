/**
   \page p_pfw The plugin framework
   
   As OPAQ is a modular system at it's core, having an abstract engine and a plugin handling framework for
   functionality.The plugin framework provides a generic abstract base class (OPAQ::Component) from which new plugins 
   can be derived. The base class provides an OPAQ::Component::configure method which takes a TiXmlElement
   pointer as input. A plugin should therefore at least implement this configure method. Every more advanced
   component, such as Forecast or Mapping models, datahandlers etc.. are in essence derived from this
   base component class and can therefore all contain a configure section in the master OPAQ configuration
   file. 

   In this master XML configuration file, each plugin (.so file) is listed under the plugins section. 
   Example : 
\code{.xml}
<plugins>
  <plugin name="XMLAQNetProviderPlugin">plugins/libXMLAQNetProvider.so</plugin>
  <plugin name="OVLDataProviderPlugin>plugins/libOVLDataProvider.so</plugin>
</plugins>
\endcode

  so in this example we list an XMLAQNetProviderPlugin as pluging name, which refers to the .so file found
  in the XML tag in the configuration section. Each .so file , which contains a OPAQ::Component
  derived class and is compiled separately as an OPAQ plugin can such be labelled. In a following section
  in the OPAQ configuration file, we can add a configuration to each of the plugins, turning them into 
  useable components within the OPAQ framework. This is configured under 

\code{.xml}
 <components>
  <component name="XMLNetworkProvider" plugin="XMLAQNetProviderPlugin">
    <config>
      <missing_value>-9999</missing_value>
      <network>
        <station name="40AB01" x="147285" y="219017" meteo="">pm10,no2</station>
        <station name="40AB02" x="146729" y="225661" meteo="">pm10,no2</station>
        <station name="40AL01" x="151150" y="214030" meteo="">pm10</station>
        <station name="40AL02" x="140660" y="221640" meteo="">pm10,no2</station>

      </network>
    </config>
  </component>

  <component name="..." plugin="...">
    <config ref="path_to_external.xml" />
  </component>
</components>
\endcode


  Components are instantiated (e.g. created via "new") upon loading, the (singleton) componentmanager simply 
  returns a pointer to the existing components. E.g. : 

  \code{.cpp}
  MLP_FeedForwardModel *model = ComponentManager::getInstance()->getComponent<MLP_FeedForwardModel>( cf->model_name );
  \endcode

  Multiple components can be made from the same plugin, simply by using a different configuration, e.g. in the 
  OVL prediction models, we use this for distinguisihing between the 9UT, 6UT and 17UT networks, which have a
  slightly differnet configuration, but are using the samen codebase. 

*/
