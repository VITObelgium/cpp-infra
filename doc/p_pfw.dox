/**
\page p_pfw The plugin framework

\section p_pfw_intro Introduction

As OPAQ is a modular system at it's core, having an abstract engine and a plugin handling framework for
functionality.The plugin framework provides a generic abstract base class (OPAQ::Component) from which new plugins 
can be derived. The base class provides an OPAQ::Component::configure method which takes a TiXmlElement
pointer as input. A plugin should therefore at least implement this configure method. Every more advanced
component, such as Forecast or Mapping models, datahandlers etc.. are in essence derived from this
base component class and can therefore all contain a configure section in the master OPAQ configuration
file. 

In this master XML configuration file, each plugin (.so file) is listed under the plugins section. 
Example : 
\code{.xml}
<plugins>
  <plugin name="XMLAQNetProviderPlugin">plugins/libXMLAQNetProvider.so</plugin>
  <plugin name="OVLDataProviderPlugin>plugins/libOVLDataProvider.so</plugin>
</plugins>
\endcode

so in this example we list an XMLAQNetProviderPlugin as pluging name, which refers to the .so file found
in the XML tag in the configuration section. Each .so file , which contains a OPAQ::Component
derived class and is compiled separately as an OPAQ plugin can such be labelled. In a following section
in the OPAQ configuration file, we can add a configuration to each of the plugins, turning them into 
useable components within the OPAQ framework. This is configured under 

\code{.xml}
 <components>
  <component name="XMLNetworkProvider" plugin="XMLAQNetProviderPlugin">
    <config>
      <missing_value>-9999</missing_value>
      <network>
        <station name="40AB01" x="147285" y="219017" meteo="">pm10,no2</station>
        <station name="40AB02" x="146729" y="225661" meteo="">pm10,no2</station>
        <station name="40AL01" x="151150" y="214030" meteo="">pm10</station>
        <station name="40AL02" x="140660" y="221640" meteo="">pm10,no2</station>

      </network>
    </config>
  </component>

  <component name="..." plugin="...">
    <config ref="path_to_external.xml" />
  </component>
</components>
\endcode


Components are instantiated (e.g. created via "new") upon loading, the (singleton) componentmanager simply 
returns a pointer to the existing components. E.g. : 

\code{.cpp}
MLP_FeedForwardModel *model = ComponentManager::getInstance()->getComponent<MLP_FeedForwardModel>( cf->model_name );
\endcode

Multiple components can be made from the same plugin, simply by using a different configuration, e.g. in the 
OVL prediction models, we use this for distinguisihing between the 9UT, 6UT and 17UT networks, which have a
slightly differnet configuration, but are using the samen codebase. 

\section p_plugindev_writing Writing your own plugins

The adaptability of OPAQ is achieved by implementing it as a simple, yet powerful plugin framework. 
All components in OPAQ are plugin-based. A plugin is a shared library that is loaded by OPAQ at runtime.
The concepts of OPAQ plugins and components are somewhat analogous to those of classes and instances.
A plugin is the analogue of a class, while a component is the analogue of an instance. OPAQ will load 
each plugin only once, but it can create several components using the same plugin. This explains the 
way in which plugins and components are configured in the OPAQ configuration file. Each plugin is given 
a unique name. Each component is also given a unique name, and the plugin from which it must be created 
is specified as well. Each component (~instance) constructed from the same plugin (~class) is characterized
by its unique configuration.

Writing a model for OPAQ comes down to writing an OPAQ plugin. This means you have to implement 2 items.

- A class that extends the OPAQ::Component abstract class. This comes down to implementing the pure 
  virtual method OPAQ::Component::configure(TiXmlElement* configuration);

- A factory method that creates a new instance of your class and returns a pointer to that new instance.
  The factory method must have the signature OPAQ::Component * factory (); and it must use "C" linkage, 
  that is the linker may not mangle the function name of the factory method.

This last item is easily handled via the OPAQ_REGISTER_PLUGIN macro. 

All other methods are specific for each plugin and are thus not of any concern to the plugin framework. 
It is however important to note that the plugin framework only loads OPAQ::Component classes, which 
are casted to the appropriate types by the users of the components. This means that all methods that 
your plugin offers to the user must be implemented as virtual methods to enable late binding. If not, 
the linker cannot link the code of the user of your plugin. The reason for this is that the code of the 
user of your plugin is not linked against your plugin, which is a shared library that is loaded at runtime,
not at link time.

An example implementation of a plugin is given below.

The header file might look like this. The configure method is the pure virtual method declared in the 
OPAQ::Component parent class. The virtual (!) echo method is the "service" offered by this plugin.

\code
#ifndef EXAMPLECOMPONENT_H_
#define EXAMPLECOMPONENT_H_

#include "Component.h"
#include <string>

namespace OPAQ {

  class ExampleComponent: public OPAQ::Component {
  public:
    ExampleComponent();
    virtual ~ExampleComponent();

    void configure(TiXmlElement* configuration);

    virtual std::string echo (std::string message);
  };

} 
#endif 
\endcode

The cpp file might look like this. This plugin does not need any configuration, so the implementation 
of the configure method remains empty. The echo method simply returns whatever it received. Important 
is the factory method:

- It is declared 'extern "C"', which tells the compiler to use 'C' linkage.
- It returns a pointer to an OPAQ::Component instance.
- It creates a new OPAQ::ExampleComponent (that is the exact type you implemented) instance using the new keyword.

\code
#include "ExampleComponent.h"

namespace OPAQ {
  ExampleComponent::ExampleComponent() {}
  ExampleComponent::~ExampleComponent() {}

  void ExampleComponent::configure(TiXmlElement* configuration) {}

  std::string ExampleComponent::echo(std::string message) {
    return message;
  }
} 

extern "C" {
  OPAQ::Component * factory () {
    return new OPAQ::ExampleComponent();
  }
}
\endcode

The last part can be replaced by the easy macro

\code
OPAQ_REGISTER_PLUGIN(OPAQ::ExampleComponent)
\endcode

\section p_pfw_using Using components within components

Each component can use other components. For that purpose, the plugin framework offers a getter method 
with a single argument; the name of the component, and which returns a pointer to the component instance 
with the given name.
  
This allows keeping the OPAQ framework simple while also allowing the implementation of arbitrary complex 
components. Note that when using this mechanism, one has to be very careful with the configuration of the 
components and the casting of the component pointer returned by the getter method to the appropriate type.

An example of this is provided by the OVL forecast model plugin, which in itself makes use of different
core ANN prediction models. These are retrieved from a configuration per station/pollutant/aggregation
time. Some (simplified) example code here below to illustrate this. 

\code
void OVL::run() {

  // ... snip ...

  OPAQ::TimeInterval fcHor( fc_hor, TimeInterval::Days );
  DateTime fcTime = baseTime + fcHor;

  // lookup the station configuration
  auto stIt = _conf.find( std::make_tuple( pol.getName(), aggr, this->tune_mode, station->getName(), fc_hor ) );

  // get a pointer to the station configuration
  StationConfig *cf = &(stIt->second);

  // get the correct model plugin, we don't have to destroy it as there is only one instance of each component,
  // configuration via the setters...
  MLP_FeedForwardModel *model = ComponentManager::getInstance()->getComponent<MLP_FeedForwardModel>( cf->model_name );

  // set ins and outs for the model here...
  // this is in fact a small engine...
  model->setBaseTime(baseTime);
  model->setPollutant( pol );
  model->setAQNetworkProvider( getAQNetworkProvider() );
  model->setForecastHorizon( getForecastHorizon() );
  model->setInputProvider( getInputProvider() );
  model->setMeteoProvider( getMeteoProvider() );
  model->setBuffer( getBuffer() );

  // run the model
  double out = model->fcValue( pol, *station, aggr, baseTime, fcHor );

// ... snip ...

}
\endcode
*/



*/
